{{cleanup}}
{{outdated|edition=java|As of [[Java Edition 1.2.1|1.2.1]], this format is no longer used.}}
The '''Region file format''' is the [[Wikipedia:Binary file|binary file format]] for storing Java Edition [[chunk]]s from [[Java Edition Beta 1.3|Beta 1.3]] to [[Java Edition 1.1|1.1]]. Each file stores a group of 32×32 chunks called a '''region'''.{{Efn|A total of 1024 chunks can be stored in the format, covering an area of 512×512 blocks.<ref>{{Citation|url=https://www.mojang.com/2012/02/new-minecraft-map-format-anvil/|title=New Minecraft Map Format, “Anvil”|author=[[Jens Bergensten|Bergensten, Jens]]|website=Mojang.com|date=February 14, 2012|archive-url=https://web.archive.org/web/20120302221152/https://www.mojang.com/2012/02/new-minecraft-map-format-anvil/|quote=Maximum build height has been increased to 256 (was 128)|archive-time=March 2, 2012}}</ref>}} The format took the place of the [[Java Edition Alpha level format|Alpha level format]], which had been in use since the [[Infdev]] development phase, where chunks were stored in individual files on the file system. The file does not begin with a [[wikipedia:Magic_number_(programming)#In_files|magic number]], unlike [[wikipedia:List_of_file_signatures|other file formats]], and begins directly with the header. The format has been superseded by the [[Anvil file format]]; however, the Anvil file format made changes only to the [[chunk format]] and changed the region file extensions from ".mcr" to ".mca".

The system is based on McRegion,<ref>http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/mods-discussion/1346703-mod-mcregion-v5-optimized-saves-1-2_02#p2619453</ref> a mod by [http://www.minecraftforum.net/members/Scaevolus Scaevolus], also known for his development of the Optimine project. The McRegion format was adopted nearly unchanged, except for the addition of a table of chunk update timestamps. [[JahKob]] has claimed that this format is up to 7 times faster than the previous system.<ref>http://www.pcgamer.com/minecraft-dev-diary-new-block-magic-fiddles/</ref> The difference in a world's total file size between the Region file format and the Alpha level format is negligible.

{{Anchor|Region files|Region file location}}

== Location ==
Region files have names in the form <code>r.''x''.''z''.mcr</code>, where x and z are the region's coordinates. The dimension of the region data dictates the sub-directory in which the region files are stored:

* '''Overworld''': ''save_directory''/region
* '''Nether''': ''save_directory''/DIM-1/region
* '''The End''': ''save_directory''/DIM1/region
The coordinates of a region file in which any given chunk resides in, can be acquired through taking the floor of dividing the chunk coordinates by 32. For example, a chunk at (30, -3) would be in the region (0, -1), and one at (1500, -600) would be at (46, -19).
Within the file, chunks are stored starting from (x=0,z=0), in "rows" of X. (I.e. (0,0) to (31,0), followed by (0,1) to (31,1), et cetera)

Alternatively, the same can be achieved through performing an [[Wikipedia:Arithmetic_shift|arithmetic shift]] 5 bits to the right.
It is important that an arithmetic shift occurs, rather than a [[Wikipedia:Logical_shift|logical shift]].
<syntaxhighlight lang="java">
// float division
Int32 regionX = (Int32)floor(chunkX / 32.0f);
Int32 regionZ = (Int32)floor(chunkZ / 32.0f);

// arithmetic shift, important that `int` is signed.
Int32 regionX = chunkX >> 5;
Int32 regionZ = chunkZ >> 5;
</syntaxhighlight>

{{:Calculators/Chunk coordinates}}

Reciprocally, the starting block coordinate of a region can be calculated by multiplying the x and z region values ''(as defined by the region file's name)'' by 512. Likewise, each chunk's starting block coordinate can be calculated by performing either modulo or floor/integer division to the chunk's index in the header table (0 through 1023) and adding the result to the region's x and z values:

<syntaxhighlight lang="java" line="1">
// get region x, z
Int32 regionX = x * 512;
Int32 regionZ = z * 512;

// get chunk x, z
Int32 chunkX = regionX + ((headerIndex % 32) * 16);
Int32 chunkZ = regionZ + ((headerIndex / 32) * 16);
</syntaxhighlight>

Converting from chunk coordinates of a region back to the header index, is done via the following formula. Where one example utilises [[Wikipedia:Bitwise_and|bitwise AND]]. This is potentially more efficient, but depending on the language the first example is optimised into the other variant at the assembly level.
To acquire the starting byte of the [[Wikipedia:Endianness|big-endian]] 32 bit integer, multiply the result of the computation below by 4. (32 / 8 = 4)
Finding the related timestamp can be done by adding 0x400 (32^2 or 1024) to the index value.
<syntaxhighlight lang="java" line="1">
// acquire header table index
int headerIndex = (x % 32) + (z % 32) * 32;

// acquire header table index (bitwise)
int headerIndex = (x & 31) + (z & 31) * 32;
</syntaxhighlight>

== Structure ==

=== Header ===
Region files begin with an 8KiB header, split into two 4KiB tables. The first containing the offsets of chunks in the region file itself, the second providing timestamps for the last updates of those chunks. 

The offset of a chunk [x, z] (in chunk coordinates) in the first table can be found by using this formula: 4 * ((x mod 32) + (z mod 32) * 32). When using certain languages (such as Java/C/C++), the values of x mod 32 and z mod 32 can be negative. To prevent this, use the AND operator (&) instead of modulo: 4 * ((x & 31) + (z & 31) * 32). Its timestamp can be found 4096 bytes later in the file. 

{| class="wikitable" data-description="High level structure"
|-
! byte
! 0x00 - 0x0FFF
! 0x1000 - 0x1FFF
! 0x2000...
|-
! description
| locations (1024 entries; 4 bytes each)
| timestamps (1024 entries; 4 bytes each)
| chunks and unused space
|}

==== Chunk location ====

Location information for a chunk consists of four bytes split into two fields: the first three bytes are a (big-endian) offset in 4KiB sectors from the start of the file (bitmask 0xFFFFFF00), and a remaining byte (0x000000FF) that gives the length of the chunk (also in 4KiB sectors, rounded up). Chunks are always less than 1MiB in size. If a chunk isn't present in the region file (e.g. because it hasn't been generated or migrated yet), both fields are zero.

{| class="wikitable" data-description="Chunk location bytes"
|-
! byte
! 0
! 1
! 2
! 3
|-
! description
| colspan="3" | offset
| sector count
|}

A chunk with an offset of 2, therefore pointing to 0x2000 (<math display="inline">2 \cdot 4096</math> in hexadecimal), begins right after the timestamps table.

==== Chunk timestamps ====

The entries in the timestamp table are individual four-byte big-endian integers, representing the last modification time of a chunk in epoch seconds.

{| class="wikitable" data-description="Chunk timestamp bytes"
|-
! byte
! 0
! 1
! 2
! 3
|-
! description
| colspan="4" | timestamp
|}
=== Payload ===

Chunk data begins with a (big-endian) four-byte signed length field that indicates the exact length of the remaining chunk data in bytes. The following byte indicates the compression scheme used for chunk data, and the remaining (length-1) bytes are the compressed chunk data.

''Minecraft'' always pads the last chunk's data to be a multiple-of-4096B in length (so that the entire file has a size that is a multiple of 4KiB). ''Minecraft'' does not accept files in which the last chunk is not padded. Note that this padding is not included in the length field.

{| class="wikitable" data-description="Chunk data bytes"
|-
! byte
! 0
! 1
! 2
! 3
! 4
! 5...
|-
! description
| colspan="4" | length (in bytes)
| compression type
| compressed data (length-1 bytes)
|}

There are currently five defined compression schemes:

{| class="wikitable" data-description="Compression schemes"
|-
! value
! method
|-
| 1
| GZip (RFC1952) (unused in practice)
|-
| 2
| Zlib (RFC1950)
|-
|3<sup>since a version before 1.15.1</sup>
|Uncompressed
|-
|4
|[[wikipedia:LZ4 (compression algorithm)|LZ4]] (since [[24w04a]], enabled in [[server.properties]])
|-
|127
|Custom compression algorithm (since [[24w05a]], for third-party servers)
A namespaced string must follow representing the algorithm used. The string is preceded by its length, encoded as an unsigned 16-bit integer.
|}

The uncompressed data is in [[NBT format]] and follows the information detailed on the [[chunk format]] article; if compressed with compression scheme 1, the compressed data would be the same as the on-disk content of an Alpha chunk file. Note that chunks are always saved using compression scheme 2 by the official client.

If the value of compression scheme increases by 128, the compressed data is saved in a file called <code>c.''x''.''z''.mcc</code>, where x and z are the chunk's coordinates, instead of the usual position.

== Migration and level.dat ==
[[File:Convert.png|thumb|How ''Minecraft'' looks when converting to the new format.]]
Beta 1.3 converts any "old" chunks into region files before loading the world, rather than incrementally, as they are loaded during play. As part of the conversion, <code>level.dat</code> is updated with TAG_Int("version") (note case) set to 19132. Beta 1.3 also introduces a new level name field, TAG_String("LevelName"). A new TAG_Byte("Sleeping") was introduced in player TAG_Compounds - level.dat in singleplayer, [player name].dat in multiplayer that indicates whether the player is in a bed. It has value of 1 (true) or 0 (false). In [[Java Edition Beta 1.8|Beta 1.8]], TAG_Int("GameType") was added. In [[Java Edition 1.0.0|1.0.0]], TAG_byte("hardcore") was added.

The format of [[Java Edition level format#level.dat format|level.dat]] is otherwise unchanged.

== See also ==

*[[Chunk format/McRegion|McRegion chunk format]]
*[[Java Edition level format]]
*[[Chunk format]]
*[[Anvil file format]]

== External links ==
*[https://web.archive.org/web/20120314044006/http://www.mojang.com/2011/02/minecraft-save-file-format-in-beta-1-3/ Mojang announcement of new region format; Jeb helping tool-makers]
*[http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/mods-discussion/1346703-mod-mcregion-v5-optimized-saves-1-2_02 McRegion]
*[http://pastebin.com/niWTqLvk RegionFile in Java]
*[http://pastebin.com/jvZ1yhAd RegionFileCache in Java]
*[https://dinnerbone.com/minecraft/tools/coordinates/ Find region file from coordinates]

== References ==

<references />

== Notes ==
{{Fnlist}}

== Software ==
The community has developed programs to work with region files:
{| class="wikitable" style="width: 100%" data-description="Region file editors"
|-
! Name
! Description
! Screenshot
|-
| [http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/mods-discussion/1346703-mod-mcregion-v5-optimized-saves-1-2_02 McRegion]
| This mod optimizes how chunks are stored on the disk, meaning pauses to load or save a chunk as the player moves around a world become much shorter and less noticeable.
|
|-
| [http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-tools/1261480-minecraft-region-fixer Minecraft Region Fixer]
| This tool is a python script that tries to fix problems in region files. It can find some typical errors (corrupted chunks, wrong located chunks, too many entities problems), and can fix these errors in various ways (deleting the chunks, replacing them with a backup copy, or relocating the chunk). This is a command-line application.
|
|-
| [http://minecraft.tournier.org MCA2NBT]
| A simple Unix command-line utility to convert a ''Minecraft'' .mca region file (in anvil format) to a directory with the same basename containing an uncompressed NBT file for each of its chunks.
|
|-
| [https://lotr-minecraft-mod-exiles.fandom.com/wiki/Minecraft_Region_Scanner Region Scanner]
| A [[Java Edition 1.7.10]] (only) Java command line utility to analyze and mass edit region files
|
|}

== Navigation ==
{{Navbox Java Edition technical|general}}

[[Category:Development]]

[[de:Spielstand-Speicherung/Region Format]]
[[fr:Format de fichier Région]]
[[ja:Regionファイルフォーマット]]
[[nl:Regio bestandsformaat]]
[[zh:区域文件格式]]